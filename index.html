<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Otenzza — your altar of presence</title>
<meta name="description" content="A private, intentional space. No feed. No vanity metrics. Just your Cube." />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Sora:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0a0a0d; --text:#e8e8ee; --muted:#9a9ab0; --ring:rgba(255,255,255,.10); }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 600px at 50% 45%, #101018 0%, var(--bg) 60%);
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
  }

  /* topo / marca */
  .topbar{position:sticky; top:0; z-index:8; display:flex; align-items:center; justify-content:center; height:82px; backdrop-filter:blur(10px)}
  .brand{display:flex; align-items:center; gap:.6rem; text-transform:uppercase; font-weight:800; letter-spacing:.18em; font-family:"Sora",Inter,sans-serif; font-size:clamp(28px,4.4vw,46px)}
  .brand-cube{width:28px; height:auto; display:block} /* AUMENTADO */

  /* hero */
  .hero{min-height:calc(100vh - 82px); display:grid; place-items:center; padding:48px 20px 72px}
  .stack{display:flex; flex-direction:column; align-items:center; text-align:center; gap:16px; width:100%; max-width:1040px}
  .title{font-size:clamp(18px,3.2vw,30px); font-weight:800; letter-spacing:-.01em}
  .subtitle{max-width:760px; line-height:1.6; color:var(--muted); font-size:clamp(12px,1.2vw,14px)}

  /* Área do cubo – quadrada SEMPRE e canvas acima do halo */
  .cube-wrap{
    width:min(540px,85vw);
    aspect-ratio: 1 / 1;
    position:relative; margin:16px 0 18px;
    touch-action:none; overscroll-behavior:contain; user-select:none;
    display:grid; place-items:center;
  }
  .cube-wrap::before{
    content:""; position:absolute; inset:-12% -12% -6% -12%;
    border-radius:50%;
    background: radial-gradient(50% 50% at 50% 60%, rgba(42,87,255,.35), transparent 70%);
    filter: blur(42px); z-index:0;
  }
  #three-canvas{
    width:100%; height:100%; display:block;
    position:relative; z-index:1;
    touch-action:none; border-radius:18px;
  }

  /* form */
  .form{display:flex; gap:12px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap}
  .input{width:min(520px,78vw); height:46px; border-radius:999px; border:1px solid var(--ring); background:rgba(255,255,255,.04); color:var(--text); padding:0 18px; outline:none; font-size:15px; backdrop-filter:blur(4px)}
  .input::placeholder{color:#8a8aa2}
  .btn{height:46px; border-radius:999px; padding:0 20px; border:1px solid rgba(255,255,255,.22); font-weight:800; cursor:pointer; background:#fff; color:#0a0a0d; box-shadow:0 2px 0 rgba(255,255,255,.6) inset, 0 12px 30px rgba(255,255,255,.10); white-space:nowrap}
  .fineprint{color:#7b7b8a; font-size:12px; margin-top:8px}

  footer{padding:52px 20px; text-align:center; color:#7b7b8a; font-size:12px}

  @media (max-width:640px){
    .brand{font-size:clamp(26px,8vw,38px)}
    .title{font-size:clamp(16px,5vw,24px)}
    .subtitle{font-size:clamp(11px,3.2vw,13px)}
  }
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand" aria-label="Otenzza">
      <!-- Cubinho do logo (substitui a bolinha) -->
      <svg class="brand-cube" viewBox="0 0 48 48" aria-hidden="true">
        <defs>
          <linearGradient id="gTop" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#74b8ff"/><stop offset="1" stop-color="#4a86ff"/>
          </linearGradient>
          <linearGradient id="gLeft" x1="1" y1="0" x2="0" y2="1">
            <stop offset="0" stop-color="#3d5eff"/><stop offset="1" stop-color="#1733ff"/>
          </linearGradient>
          <linearGradient id="gRight" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#4a6aff"/><stop offset="1" stop-color="#244bff"/>
          </linearGradient>
        </defs>
        <polygon points="24,4 8,12 24,20 40,12" fill="url(#gTop)"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="url(#gLeft)"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="url(#gRight)"/>
        <polygon points="24,4 8,12 24,20 40,12" fill="none" stroke="rgba(255,255,255,.35)" stroke-width=".9"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
      </svg>
      <span>OTENZZA</span>
    </div>
  </header>

  <main class="hero">
    <div class="stack">
      <h1 class="title">Presence. Identity. Precision.</h1>
      <p class="subtitle">A private, intentional space. No feed. No vanity metrics. Just your Cube.</p>

      <!-- CUBO 3D -->
      <div class="cube-wrap" id="cube-wrap">
        <canvas id="three-canvas"></canvas>
      </div>

      <form class="form" onsubmit="event.preventDefault(); alert('Reserved. Welcome to the circle.');">
        <input class="input" type="email" placeholder="your@email.com" required aria-label="Email"/>
        <button class="btn" type="submit">Reserve early access</button>
      </form>
      <div class="fineprint">Founding members — limited circle.</div>
    </div>
  </main>

  <footer>© 2025 Otenzza.</footer>

  <!-- Three.js (UMD) -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    (function(){
      const container = document.getElementById('cube-wrap');
      const canvas    = document.getElementById('three-canvas');

      let renderer, scene, camera, cube;
      let dragging=false, lx=0, ly=0, rx=-0.6, ry=0.8; // ângulos iniciais (rad)
      let idle = true;
// === textura marmorizada procedural (canvas) ===
function makeMarbleTexture(size=512, veinScale=5.0, veinStrength=4.0, seed=1337){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size,size); const data = img.data;

  const lerp=(a,b,t)=>a+(b-a)*t;
  const smooth=t=>t*t*(3-2*t);
  const hash=(x,y)=>{
    const s = Math.sin(x*127.1 + y*311.7 + seed) * 43758.5453123;
    return s - Math.floor(s);
  };
  const noise=(x,y)=>{
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi;
    const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
    const u=smooth(xf), v=smooth(yf);
    return lerp(lerp(v00,v10,u), lerp(v01,v11,u), v);
  };
  const fbm=(x,y,oct=5)=>{
    let val=0, amp=0.5, freq=1.0;
    for(let i=0;i<oct;i++){ val += amp*noise(x*freq, y*freq); freq*=2.02; amp*=0.5; }
    return val;
  };

  const angle = 0.6; // rotação das veias (rad)
  const ca=Math.cos(angle), sa=Math.sin(angle);

  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const nx=x/size, ny=y/size;

      // coordenadas “ao longo da veia”
      const sx = (nx*ca - ny*sa) * veinScale;
      const sy = (nx*sa + ny*ca) * veinScale;

      // turbolência e padrão de mármore
      const t = fbm(sx, sy, 5);
      let m = Math.sin(sx + t*veinStrength); // -1..1
      m = (m+1)/2;                           // 0..1
      m = Math.pow(m, 1.6);                  // contraste suave
      const speck = fbm(sx*3.0, sy*3.0, 2) * 0.08; // pontilhado leve
      let v = Math.min(1, Math.max(0, m + speck));

      // leve “tint” para azul
      const i=(y*size + x)*4;
      data[i  ] = Math.round((0.75*v + 0.25) * 255); // R
      data[i+1] = Math.round((0.82*v + 0.18) * 255); // G
      data[i+2] = Math.round((1.00*v + 0.20) * 255); // B
      data[i+3] = 255;
    }
  }
  ctx.putImageData(img,0,0);

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.MirroredRepeatWrapping; // evita emendas
  tex.anisotropy = 8;
  return tex;
}

      function init(){
        renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene  = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);

        /* >>> ALTERAÇÃO: câmera centralizada e um pouco mais distante <<< */
        camera.position.set(0, 0, 3.8);
        camera.lookAt(0,0,0);

        scene.add(new THREE.AmbientLight(0xffffff, 0.55));
        const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,4,5); scene.add(dir);
        const rim = new THREE.PointLight(0x6d8bff, 0.7); rim.position.set(-4,-2,-3); scene.add(rim);

        const geo = new THREE.BoxGeometry(1,1,1);
// Cubo (6 faces reais)
const geo = new THREE.BoxGeometry(1,1,1);

// textura marmorizada azul (padrão suave)
const marbleTex = makeMarbleTexture(512, /*veinScale*/ 5.0, /*veinStrength*/ 4.0);
marbleTex.repeat.set(1.5, 1.5); // deixa as veias mais frequentes

const mat = new THREE.MeshPhysicalMaterial({
  color: 0x2f5aff,          // azul base (tinta sobre o marble)
  map: marbleTex,           // aplica o mármore
  metalness: 0.08,
  roughness: 0.32,          // um pouco mais “mineral”
  clearcoat: 0.45,
  clearcoatRoughness: 0.08,
  transparent: true,
  opacity: 0.95
});

const cube = new THREE.Mesh(geo, mat);

        const edges = new THREE.EdgesGeometry(geo);
        cube.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0xffffff, opacity:0.25, transparent:true})));
        scene.add(cube);

        applyRot();
        resize();

        canvas.addEventListener('pointerdown', onDown, {passive:false});
        canvas.addEventListener('pointermove', onMove, {passive:false});
        canvas.addEventListener('pointerup', onUp, {passive:false});
        canvas.addEventListener('pointercancel', onUp, {passive:false});
        canvas.addEventListener('wheel', e=>e.preventDefault(), {passive:false});

        requestAnimationFrame(tick);
      }

      function applyRot(){ cube.rotation.x = rx; cube.rotation.y = ry; }

      function onDown(e){
        dragging = true; idle = false; lx = e.clientX; ly = e.clientY;
        canvas.setPointerCapture(e.pointerId);
        e.preventDefault();
      }
      function onMove(e){
        if(!dragging) return;
        const dx = e.clientX - lx;
        const dy = e.clientY - ly;
        ry += dx * 0.01;
        rx -= dy * 0.01;
        rx = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, rx));
        applyRot();
        lx = e.clientX; ly = e.clientY;
        e.preventDefault();
      }
      function onUp(e){
        dragging = false; idle = true;
        try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
      }

      function resize(){
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        const s = Math.min(w, h);
        cube.scale.setScalar(s / 600); // mesmo tamanho visual de antes
      }
      window.addEventListener('resize', resize);

      function tick(){
        if(idle){ ry += 0.003; applyRot(); }
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }

      if (document.readyState === 'complete') init();
      else window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
