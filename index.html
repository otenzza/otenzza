<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Otenzza — your altar of presence</title>
<meta name="description" content="A private, intentional space. No feed. No vanity metrics. Just your Cube." />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Sora:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0a0a0d; --text:#e8e8ee; --muted:#9a9ab0; --ring:rgba(255,255,255,.10); }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 600px at 50% 45%, #101018 0%, var(--bg) 60%);
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
  }

  .topbar{position:sticky; top:0; z-index:8; display:flex; align-items:center; justify-content:center; height:82px; backdrop-filter:blur(10px)}
  .brand{display:flex; align-items:center; gap:.6rem; text-transform:uppercase; font-weight:800; letter-spacing:.18em; font-family:"Sora",Inter,sans-serif; font-size:clamp(28px,4.4vw,46px)}
  .brand-cube{width:28px; height:auto; display:block}

  .hero{min-height:calc(100vh - 82px); display:grid; place-items:center; padding:48px 20px 72px}
  .stack{display:flex; flex-direction:column; align-items:center; text-align:center; gap:16px; width:100%; max-width:1040px}
  .title{font-size:clamp(18px,3.2vw,30px); font-weight:800; letter-spacing:-.01em}
  .subtitle{max-width:760px; line-height:1.6; color:var(--muted); font-size:clamp(12px,1.2vw,14px)}

  .cube-wrap{
    width:min(540px,85vw);
    aspect-ratio: 1 / 1;
    position:relative; margin:16px 0 18px;
    touch-action:none; overscroll-behavior:contain; user-select:none;
    display:grid; place-items:center;
  }
  .cube-wrap::before{
    content:""; position:absolute; inset:-12% -12% -6% -12%;
    border-radius:50%;
    background: radial-gradient(50% 50% at 50% 60%, rgba(42,87,255,.35), transparent 70%);
    filter: blur(42px); z-index:0;
  }
  #three-canvas{
    width:100%; height:100%; display:block;
    position:relative; z-index:1;
    touch-action:none; border-radius:18px;
  }

  .form{display:flex; gap:12px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap}
  .input{width:min(520px,78vw); height:46px; border-radius:999px; border:1px solid var(--ring); background:rgba(255,255,255,.04); color:var(--text); padding:0 18px; outline:none; font-size:15px; backdrop-filter:blur(4px)}
  .input::placeholder{color:#8a8aa2}
  .btn{height:46px; border-radius:999px; padding:0 20px; border:1px solid rgba(255,255,255,.22); font-weight:800; cursor:pointer; background:#fff; color:#0a0a0d; box-shadow:0 2px 0 rgba(255,255,255,.6) inset, 0 12px 30px rgba(255,255,255,.10)}
  .fineprint{color:#7b7b8a; font-size:12px; margin-top:8px}
  footer{padding:52px 20px; text-align:center; color:#7b7b8a; font-size:12px}
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand" aria-label="Otenzza">
      <svg class="brand-cube" viewBox="0 0 48 48" aria-hidden="true">
        <defs>
          <linearGradient id="gTop" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#74b8ff"/><stop offset="1" stop-color="#4a86ff"/>
          </linearGradient>
          <linearGradient id="gLeft" x1="1" y1="0" x2="0" y2="1">
            <stop offset="0" stop-color="#3d5eff"/><stop offset="1" stop-color="#1733ff"/>
          </linearGradient>
          <linearGradient id="gRight" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#4a6aff"/><stop offset="1" stop-color="#244bff"/>
          </linearGradient>
        </defs>
        <polygon points="24,4 8,12 24,20 40,12" fill="url(#gTop)"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="url(#gLeft)"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="url(#gRight)"/>
        <polygon points="24,4 8,12 24,20 40,12" fill="none" stroke="rgba(255,255,255,.35)" stroke-width=".9"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
      </svg>
      <span>OTENZZA</span>
    </div>
  </header>

  <main class="hero">
    <div class="stack">
      <h1 class="title">Presence. Identity. Precision.</h1>
      <p class="subtitle">A private, intentional space. No feed. No vanity metrics. Just your Cube.</p>

      <div class="cube-wrap" id="cube-wrap">
        <canvas id="three-canvas"></canvas>
      </div>

      <form class="form" onsubmit="event.preventDefault(); alert('Reserved. Welcome to the circle.');">
        <input class="input" type="email" placeholder="your@email.com" required aria-label="Email"/>
        <button class="btn" type="submit">Reserve early access</button>
      </form>
      <div class="fineprint">Founding members — limited circle.</div>
    </div>
  </main>

  <footer>© 2025 Otenzza.</footer>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    (function(){
      const container = document.getElementById('cube-wrap');
      const canvas    = document.getElementById('three-canvas');

      let renderer, scene, camera, outerCube, rimMesh, volumeCube;
      let dragging=false, lx=0, ly=0, rx=-0.6, ry=0.8;
      let idle = true;

      function init(){
        renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true, powerPreference:'high-performance'});
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.08;
        renderer.physicallyCorrectLights = true;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene  = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
        camera.position.set(0, 0, 3.8);
        camera.lookAt(0,0,0);

        scene.add(new THREE.AmbientLight(0xffffff, 0.55));
        const key = new THREE.DirectionalLight(0xffffff, 1.15); key.position.set(3.5,4,5); scene.add(key);
        const fill = new THREE.DirectionalLight(0x8bbcff, 0.65); fill.position.set(-4,-2,-3); scene.add(fill);
        const bounce = new THREE.PointLight(0x3a66ff, 0.7, 8); bounce.position.set(0,-2,0); scene.add(bounce);

        const geo = new THREE.BoxGeometry(1,1,1);

        /* Vidro externo — depthWrite DESLIGADO para o volume aparecer */
        const outerMat = new THREE.MeshPhysicalMaterial({
          color: 0x7bb6ff,
          metalness: 0.0,
          roughness: 0.10,
          clearcoat: 0.9,
          clearcoatRoughness: 0.06,
          transparent: true,
          opacity: 0.38,
          transmission: 1.0,
          ior: 1.31,
          thickness: 1.8,
          attenuationColor: new THREE.Color(0x9ed9ff),
          attenuationDistance: 3.0,
          depthWrite: false    /* <- crucial */
        });
        outerCube = new THREE.Mesh(geo, outerMat);
        outerCube.renderOrder = 2;    /* desenha depois do volume */
        scene.add(outerCube);

        /* Fresnel (brilho de borda) */
        const rimShader = new THREE.ShaderMaterial({
          transparent:true, depthWrite:false,
          blending: THREE.AdditiveBlending,
          uniforms:{
            uColor: {value: new THREE.Color(0xbfe6ff)},
            uPower: {value: 2.0},
            uGain:  {value: 0.6}
          },
          vertexShader: `
            varying vec3 vN; varying vec3 vW;
            void main(){
              vN = normalize(normalMatrix * normal);
              vec4 wp = modelMatrix * vec4(position,1.0);
              vW = wp.xyz;
              gl_Position = projectionMatrix * viewMatrix * wp;
            }
          `,
          fragmentShader: `
            uniform vec3 uColor; uniform float uPower; uniform float uGain;
            varying vec3 vN; varying vec3 vW;
            void main(){
              vec3 V = normalize(cameraPosition - vW);
              float f = pow(1.0 - max(dot(normalize(vN), V), 0.0), uPower);
              gl_FragColor = vec4(uColor * f * uGain, f * uGain);
            }
          `
        });
        rimMesh = new THREE.Mesh(geo, rimShader);
        rimMesh.scale.setScalar(1.002);
        rimMesh.renderOrder = 3;      /* depois do vidro */
        outerCube.add(rimMesh);

        /* Volume interno — fluido com raymarch (ordem 1) */
        const volumeUniforms = {
          uTime:      { value: 0 },
          uModelInv:  { value: new THREE.Matrix4() },
          uColor:     { value: new THREE.Color(0x79c6ff) },
          uIntensity: { value: 1.8 },  // mais vivo
          uSteps:     { value: 48 }
        };
        const volumeMat = new THREE.ShaderMaterial({
          uniforms: volumeUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
          vertexShader: `
            varying vec3 vWorldPos;
            void main(){
              vec4 wp = modelMatrix * vec4(position,1.0);
              vWorldPos = wp.xyz;
              gl_Position = projectionMatrix * viewMatrix * wp;
            }
          `,
          fragmentShader: `
            precision highp float;
            varying vec3 vWorldPos;
            uniform mat4 uModelInv;
            uniform float uTime;
            uniform vec3  uColor;
            uniform float uIntensity;
            uniform int   uSteps;

            float hash(vec3 p){ return fract(sin(dot(p, vec3(127.1,311.7, 74.7))) * 43758.5453); }
            float noise(vec3 x){
              vec3 i = floor(x), f = fract(x), u = f*f*(3.0-2.0*f);
              float n000 = hash(i+vec3(0,0,0));
              float n100 = hash(i+vec3(1,0,0));
              float n010 = hash(i+vec3(0,1,0));
              float n110 = hash(i+vec3(1,1,0));
              float n001 = hash(i+vec3(0,0,1));
              float n101 = hash(i+vec3(1,0,1));
              float n011 = hash(i+vec3(0,1,1));
              float n111 = hash(i+vec3(1,1,1));
              float n00 = mix(n000,n100,u.x);
              float n01 = mix(n001,n101,u.x);
              float n10 = mix(n010,n110,u.x);
              float n11 = mix(n011,n111,u.x);
              float n0 = mix(n00,n10,u.y);
              float n1 = mix(n01,n11,u.y);
              return mix(n0,n1,u.z);
            }
            float fbm(vec3 p){
              float v=0.0; float a=0.55; vec3 shift = vec3(10.3,19.7,7.1);
              for(int i=0;i<5;i++){ v += a*noise(p); p = p*2.02 + shift; a *= 0.5; }
              return v;
            }
            vec2 boxIntersect(vec3 ro, vec3 rd){
              vec3 mn = vec3(-0.5), mx = vec3(0.5);
              vec3 t0 = (mn - ro)/rd, t1 = (mx - ro)/rd;
              vec3 tmin = min(t0,t1), tmax = max(t0,t1);
              float tE = max(max(tmin.x,tmin.y),tmin.z);
              float tX = min(min(tmax.x,tmax.y),tmax.z);
              return vec2(tE, tX);
            }
            void main(){
              vec3 roW = cameraPosition;
              vec3 rdW = normalize(vWorldPos - cameraPosition);
              vec3 ro  = (uModelInv * vec4(roW,1.0)).xyz;
              vec3 rd  = normalize((uModelInv * vec4(rdW,0.0)).xyz);

              vec2 tb = boxIntersect(ro, rd);
              if(tb.x>tb.y) discard;

              float t0 = max(tb.x, 0.0), t1 = tb.y;
              float steps = float(uSteps);
              float dt = (t1 - t0) / steps;

              vec3  col = vec3(0.0);
              float acc = 0.0;

              for(int i=0;i<96;i++){
                if(float(i)>=steps) break;
                float t = t0 + (float(i)+0.5)*dt;
                vec3 p = ro + rd*t;
                vec3 q = p*3.8 + vec3(0.22*uTime, 0.16*uTime, -0.19*uTime);
                float d = smoothstep(0.45, 0.95, fbm(q));
                d *= 0.07;                    // densidade por passo (um pouco maior)
                col += d * uColor * uIntensity;
                acc += d;
                if(acc>1.25) break;
              }
              col = clamp(col, 0.0, 1.0);
              float alpha = clamp(acc, 0.0, 1.0);
              gl_FragColor = vec4(col, alpha);
            }
          `
        });
        volumeCube = new THREE.Mesh(geo, volumeMat);
        volumeCube.scale.setScalar(0.98);
        volumeCube.renderOrder = 1;   /* desenha antes do vidro */
        outerCube.add(volumeCube);

        applyRot();
        resize();

        canvas.addEventListener('pointerdown', onDown, {passive:false});
        canvas.addEventListener('pointermove', onMove, {passive:false});
        canvas.addEventListener('pointerup', onUp, {passive:false});
        canvas.addEventListener('pointercancel', onUp, {passive:false});
        canvas.addEventListener('wheel', e=>e.preventDefault(), {passive:false});

        let last = performance.now();
        function tick(now){
          const dt = Math.min(0.05, (now - last)/1000); last = now;

          if(idle){ ry += 0.0010; applyRot(); }        // giro bem lento
          volumeMat.uniforms.uTime.value += dt * 0.50; // fluido lento
          volumeMat.uniforms.uModelInv.value.copy(volumeCube.matrixWorld).invert();

          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      function applyRot(){ outerCube.rotation.x = rx; outerCube.rotation.y = ry; }
      function onDown(e){ dragging=true; idle=false; lx=e.clientX; ly=e.clientY; canvas.setPointerCapture(e.pointerId); e.preventDefault(); }
      function onMove(e){ if(!dragging)return; const dx=e.clientX-lx, dy=e.clientY-ly; ry+=dx*0.01; rx-=dy*0.01; rx=Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, rx)); applyRot(); lx=e.clientX; ly=e.clientY; e.preventDefault(); }
      function onUp(e){ dragging=false; idle=true; try{canvas.releasePointerCapture(e.pointerId);}catch(_){} e.preventDefault(); }

      function resize(){
        const w = container.clientWidth, h = container.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w/h; camera.updateProjectionMatrix();
        const s = Math.min(w, h);
        outerCube.scale.setScalar(s / 600);  // ~60% do “cheio”
      }
      window.addEventListener('resize', resize);

      if (document.readyState === 'complete') init();
      else window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
