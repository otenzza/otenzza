<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Otenzza — your altar of presence</title>
<meta name="description" content="A private, intentional space. No feed. No vanity metrics. Just your Cube." />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Sora:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0a0a0d; --text:#e8e8ee; --muted:#9a9ab0; --ring:rgba(255,255,255,.10); }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 600px at 50% 45%, #101018 0%, var(--bg) 60%);
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
  }

  .topbar{position:sticky; top:0; z-index:8; display:flex; align-items:center; justify-content:center; height:82px; backdrop-filter:blur(10px)}
  .brand{display:flex; align-items:center; gap:.6rem; text-transform:uppercase; font-weight:800; letter-spacing:.18em; font-family:"Sora",Inter,sans-serif; font-size:clamp(28px,4.4vw,46px)}
  .brand-cube{width:28px; height:auto; display:block}

  .hero{min-height:calc(100vh - 82px); display:grid; place-items:center; padding:48px 20px 72px}
  .stack{display:flex; flex-direction:column; align-items:center; text-align:center; gap:16px; width:100%; max-width:1040px}
  .title{font-size:clamp(18px,3.2vw,30px); font-weight:800; letter-spacing:-.01em}
  .subtitle{max-width:760px; line-height:1.6; color:var(--muted); font-size:clamp(12px,1.2vw,14px)}

  .cube-wrap{
    width:min(540px,85vw);
    aspect-ratio: 1 / 1;
    position:relative; margin:16px 0 18px;
    touch-action:none; overscroll-behavior:contain; user-select:none;
    display:grid; place-items:center;
  }
  .cube-wrap::before{
    content:""; position:absolute; inset:-12% -12% -6% -12%;
    border-radius:50%;
    background: radial-gradient(50% 50% at 50% 60%, rgba(42,87,255,.40), transparent 72%);
    filter: blur(44px); z-index:0;
  }
  #three-canvas{
    width:100%; height:100%; display:block;
    position:relative; z-index:1; touch-action:none; border-radius:18px;
  }

  .form{display:flex; gap:12px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap}
  .input{width:min(520px,78vw); height:46px; border-radius:999px; border:1px solid var(--ring); background:rgba(255,255,255,.04); color:var(--text); padding:0 18px; outline:none; font-size:15px; backdrop-filter:blur(4px)}
  .input::placeholder{color:#8a8aa2}
  .btn{height:46px; border-radius:999px; padding:0 20px; border:1px solid rgba(255,255,255,.22); font-weight:800; cursor:pointer; background:#fff; color:#0a0a0d; box-shadow:0 2px 0 rgba(255,255,255,.6) inset, 0 12px 30px rgba(255,255,255,.10)}
  .fineprint{color:#7b7b8a; font-size:12px; margin-top:8px}
  footer{padding:52px 20px; text-align:center; color:#7b7b8a; font-size:12px}
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand" aria-label="Otenzza">
      <!-- cubinho do logo -->
      <svg class="brand-cube" viewBox="0 0 48 48" aria-hidden="true">
        <defs>
          <linearGradient id="gTop" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#74b8ff"/><stop offset="1" stop-color="#4a86ff"/>
          </linearGradient>
          <linearGradient id="gLeft" x1="1" y1="0" x2="0" y2="1">
            <stop offset="0" stop-color="#3d5eff"/><stop offset="1" stop-color="#1733ff"/>
          </linearGradient>
          <linearGradient id="gRight" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#4a6aff"/><stop offset="1" stop-color="#244bff"/>
          </linearGradient>
        </defs>
        <polygon points="24,4 8,12 24,20 40,12" fill="url(#gTop)"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="url(#gLeft)"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="url(#gRight)"/>
        <polygon points="24,4 8,12 24,20 40,12" fill="none" stroke="rgba(255,255,255,.35)" stroke-width=".9"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
      </svg>
      <span>OTENZZA</span>
    </div>
  </header>

  <main class="hero">
    <div class="stack">
      <h1 class="title">Presence. Identity. Precision.</h1>
      <p class="subtitle">A private, intentional space. No feed. No vanity metrics. Just your Cube.</p>

      <div class="cube-wrap" id="cube-wrap">
        <canvas id="three-canvas"></canvas>
      </div>

      <form class="form" onsubmit="event.preventDefault(); alert('Reserved. Welcome to the circle.');">
        <input class="input" type="email" placeholder="your@email.com" required aria-label="Email"/>
        <button class="btn" type="submit">Reserve early access</button>
      </form>
      <div class="fineprint">Founding members — limited circle.</div>
    </div>
  </main>

  <footer>© 2025 Otenzza.</footer>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    (function(){
      const container = document.getElementById('cube-wrap');
      const canvas    = document.getElementById('three-canvas');

      let renderer, scene, camera, outerCube, rimA, rimB, volumeCube;
      let dragging=false, lx=0, ly=0, rx=-0.6, ry=0.8;
      let idle = true;

      function init(){
        renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true, powerPreference:'high-performance'});
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.12;                 // um pouco mais de presença
        renderer.physicallyCorrectLights = true;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene  = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
        camera.position.set(0, 0, 3.8);
        camera.lookAt(0,0,0);

        /* Luz */
        scene.add(new THREE.AmbientLight(0xbfd9ff, 0.55));
        const key = new THREE.DirectionalLight(0xffffff, 1.25); key.position.set(3.5,4.2,5.2); scene.add(key);
        const fill = new THREE.DirectionalLight(0x8bbcff, 0.7); fill.position.set(-4,-2.2,-3.2); scene.add(fill);
        const bounce = new THREE.PointLight(0x2b5dff, 0.9, 8); bounce.position.set(0,-2,0); scene.add(bounce);

        const geo = new THREE.BoxGeometry(1,1,1);

        /* Vidro “grosso”/azulado: transmission + tint + sem depthWrite */
        const outerMat = new THREE.MeshPhysicalMaterial({
          color: 0x5aa0ff,            // base mais azul
          metalness: 0.0,
          roughness: 0.07,
          clearcoat: 0.95,
          clearcoatRoughness: 0.05,
          transparent: true,
          opacity: 0.52,              // um pouco mais opaco -> aspecto de vidro espesso
          transmission: 1.0,
          ior: 1.33,                  // vidro/água
          thickness: 2.6,             // “paredes” mais grossas = bordas com cor
          attenuationColor: new THREE.Color(0x62b7ff),
          attenuationDistance: 1.55,  // mais curto => mais cor azul
          depthWrite: false           // não mata o volume
        });
        outerCube = new THREE.Mesh(geo, outerMat);
        outerCube.renderOrder = 2;
        scene.add(outerCube);

        /* Dois rims (Fresnel) para borda com camada de luz */
        function makeRim(colorHex, power, gain){
          return new THREE.ShaderMaterial({
            transparent:true, depthWrite:false,
            blending: THREE.AdditiveBlending,
            uniforms:{
              uColor: {value: new THREE.Color(colorHex)},
              uPower: {value: power},
              uGain:  {value: gain}
            },
            vertexShader: `
              varying vec3 vN; varying vec3 vW;
              void main(){
                vN = normalize(normalMatrix * normal);
                vec4 wp = modelMatrix * vec4(position,1.0);
                vW = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
              }
            `,
            fragmentShader: `
              uniform vec3 uColor; uniform float uPower; uniform float uGain;
              varying vec3 vN; varying vec3 vW;
              void main(){
                vec3 V = normalize(cameraPosition - vW);
                float f = pow(1.0 - max(dot(normalize(vN), V), 0.0), uPower);
                gl_FragColor = vec4(uColor * f * uGain, f * uGain);
              }
            `
          });
        }
        rimA = new THREE.Mesh(geo, makeRim(0xbfe6ff, 2.2, 0.85));  // claro
        rimA.scale.setScalar(1.003);
        rimA.renderOrder = 3;
        outerCube.add(rimA);

        rimB = new THREE.Mesh(geo, makeRim(0x3f7cff, 2.8, 0.65));  // azul profundo por baixo
        rimB.scale.setScalar(1.001);
        rimB.renderOrder = 2.9;
        outerCube.add(rimB);

        /* Volume interno — fluido HD com jitter + domain-warp + curl */
        const volumeUniforms = {
          uTime:      { value: 0 },
          uModelInv:  { value: new THREE.Matrix4() },
          uColorA:    { value: new THREE.Color(0x6fc3ff) }, // base
          uColorB:    { value: new THREE.Color(0xc4e7ff) }, // highlights
          uIntensity: { value: 2.15 },                      // força do brilho interno
          uSteps:     { value: 84 },                        // + passos = + qualidade
          uSeed:      { value: Math.random()*1000.0 }       // jitter
        };

        const volumeMat = new THREE.ShaderMaterial({
          uniforms: volumeUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
          vertexShader: `
            varying vec3 vWorldPos;
            void main(){
              vec4 wp = modelMatrix * vec4(position,1.0);
              vWorldPos = wp.xyz;
              gl_Position = projectionMatrix * viewMatrix * wp;
            }
          `,
          fragmentShader: `
            precision highp float;
            varying vec3 vWorldPos;
            uniform mat4  uModelInv;
            uniform float uTime;
            uniform float uIntensity;
            uniform int   uSteps;
            uniform float uSeed;
            uniform vec3  uColorA, uColorB;

            /* rand / noise ------------------------------------------------- */
            float hash1(float n){ return fract(sin(n)*43758.5453); }
            float hash3(vec3 p){ return fract(sin(dot(p,vec3(127.1,311.7,74.7)))*43758.5453); }

            float noise(vec3 x){
              vec3 i=floor(x), f=fract(x), u=f*f*(3.0-2.0*f);
              float n000=hash3(i+vec3(0,0,0)), n100=hash3(i+vec3(1,0,0));
              float n010=hash3(i+vec3(0,1,0)), n110=hash3(i+vec3(1,1,0));
              float n001=hash3(i+vec3(0,0,1)), n101=hash3(i+vec3(1,0,1));
              float n011=hash3(i+vec3(0,1,1)), n111=hash3(i+vec3(1,1,1));
              float n00=mix(n000,n100,u.x), n01=mix(n001,n101,u.x);
              float n10=mix(n010,n110,u.x), n11=mix(n011,n111,u.x);
              float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
              return mix(n0,n1,u.z);
            }

            /* FBM com domain-warp ------------------------------------------ */
            float fbm(vec3 p){
              float v=0.0; float a=0.55; vec3 shift=vec3(10.3,19.7,7.1);
              for(int i=0;i<6;i++){ v+=a*noise(p); p=p*2.02+shift; a*=0.5; }
              return v;
            }

            /* Curl-noise simples (aprox) para fluxo suave ------------------ */
            vec3 curl(vec3 p){
              float e=0.2;
              vec3 dx=vec3(e,0,0), dy=vec3(0,e,0), dz=vec3(0,0,e);
              float x = fbm(p+dy)-fbm(p-dy) - (fbm(p+dz)-fbm(p-dz));
              float y = fbm(p+dz)-fbm(p-dz) - (fbm(p+dx)-fbm(p-dx));
              float z = fbm(p+dx)-fbm(p-dx) - (fbm(p+dy)-fbm(p-dy));
              return normalize(vec3(x,y,z));
            }

            /* Ray/AABB [-0.49,0.49] evita z-fight com o vidro -------------- */
            vec2 boxIntersect(vec3 ro, vec3 rd){
              vec3 mn=vec3(-0.49), mx=vec3(0.49);
              vec3 t0=(mn-ro)/rd, t1=(mx-ro)/rd;
              vec3 tmin=min(t0,t1), tmax=max(t0,t1);
              float tE=max(max(tmin.x,tmin.y),tmin.z);
              float tX=min(min(tmax.x,tmax.y),tmax.z);
              return vec2(tE,tX);
            }

            void main(){
              vec3 roW = cameraPosition;
              vec3 rdW = normalize(vWorldPos - cameraPosition);
              vec3 ro  = (uModelInv * vec4(roW,1.0)).xyz;
              vec3 rd  = normalize((uModelInv * vec4(rdW,0.0)).xyz);

              vec2 tb = boxIntersect(ro, rd);
              if(tb.x>tb.y) discard;

              float t0 = max(tb.x,0.0), t1=tb.y;
              float steps = float(uSteps);
              float dt = (t1 - t0) / steps;

              /* Jitter do primeiro sample para desfocar “steps” (anti-banding) */
              float rnd = hash1(dot(rd, vec3(12.9898,78.233,37.719)) + uSeed);
              float t = t0 + (rnd)*dt;

              vec3  col = vec3(0.0);
              float acc = 0.0;

              /* parâmetros do fluido */
              float speed = 0.42;        // velocidade geral
              float densK = 0.08;        // densidade por passo
              float warp  = 0.65;        // força do domain-warp

              for(int i=0;i<120;i++){
                if(float(i)>=steps) break;

                vec3 p = ro + rd*t;

                /* campo animado: mistura fbm + curl para “água corrente” */
                vec3 q = p*4.0;
                q += speed*uTime*vec3(0.24, 0.17, -0.21);
                vec3 w = curl(q*0.9 + vec3(0.0, 0.7*uTime, 0.3*uTime));
                q += warp * w;

                float d = fbm(q);
                d = smoothstep(0.40, 0.98, d);  // contraste do fluido
                d *= densK;

                /* coloração bicolor (profundo + highlights) */
                vec3 c = mix(uColorA, uColorB, clamp(d*3.0, 0.0, 1.0));
                col += c * d * uIntensity;
                acc += d;

                if(acc>1.35) break;      // saturou a luz interna

                t += dt;
              }

              col = clamp(col, 0.0, 1.0);
              float alpha = clamp(acc, 0.0, 1.0);
              gl_FragColor = vec4(col, alpha);
            }
          `
        });

        volumeCube = new THREE.Mesh(geo, volumeMat);
        volumeCube.scale.setScalar(0.985);      // levemente menor, “imerso” no vidro
        volumeCube.renderOrder = 1;
        outerCube.add(volumeCube);

        applyRot();
        resize();

        canvas.addEventListener('pointerdown', onDown, {passive:false});
        canvas.addEventListener('pointermove', onMove, {passive:false});
        canvas.addEventListener('pointerup', onUp, {passive:false});
        canvas.addEventListener('pointercancel', onUp, {passive:false});
        canvas.addEventListener('wheel', e=>e.preventDefault(), {passive:false});

        let last = performance.now();
        function tick(now){
          const dt = Math.min(0.05, (now - last)/1000); last = now;

          if(idle){ ry += 0.0010; applyRot(); }         // giro muito suave
          volumeMat.uniforms.uTime.value += dt;         // animação fluida
          volumeMat.uniforms.uModelInv.value.copy(volumeCube.matrixWorld).invert();

          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      function applyRot(){ outerCube.rotation.x = rx; outerCube.rotation.y = ry; }
      function onDown(e){ dragging=true; idle=false; lx=e.clientX; ly=e.clientY; canvas.setPointerCapture(e.pointerId); e.preventDefault(); }
      function onMove(e){ if(!dragging)return; const dx=e.clientX-lx, dy=e.clientY-ly; ry+=dx*0.01; rx-=dy*0.01; rx=Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, rx)); applyRot(); lx=e.clientX; ly=e.clientY; e.preventDefault(); }
      function onUp(e){ dragging=false; idle=true; try{canvas.releasePointerCapture(e.pointerId);}catch(_){} e.preventDefault(); }

      function resize(){
        const w = container.clientWidth, h = container.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w/h; camera.updateProjectionMatrix();
        const s = Math.min(w, h);
        outerCube.scale.setScalar(s / 600);  // ~60% do “cheio”
      }
      window.addEventListener('resize', resize);

      if (document.readyState === 'complete') init();
      else window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
