<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Otenzza — your altar of presence</title>
<meta name="description" content="A private, intentional space. No feed. No vanity metrics. Just your Cube." />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Sora:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0a0a0d; --text:#e8e8ee; --muted:#9a9ab0; --ring:rgba(255,255,255,.10); }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 600px at 50% 45%, #101018 0%, var(--bg) 60%);
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
  }

  /* topo / marca */
  .topbar{position:sticky; top:0; z-index:8; display:flex; align-items:center; justify-content:center; height:82px; backdrop-filter:blur(10px)}
  .brand{display:flex; align-items:center; gap:.6rem; text-transform:uppercase; font-weight:800; letter-spacing:.18em; font-family:"Sora",Inter,sans-serif; font-size:clamp(28px,4.4vw,46px)}
  .brand-cube{width:28px; height:auto; display:block}

  /* hero */
  .hero{min-height:calc(100vh - 82px); display:grid; place-items:center; padding:48px 20px 72px}
  .stack{display:flex; flex-direction:column; align-items:center; text-align:center; gap:16px; width:100%; max-width:1040px}
  .title{font-size:clamp(18px,3.2vw,30px); font-weight:800; letter-spacing:-.01em}
  .subtitle{max-width:760px; line-height:1.6; color:var(--muted); font-size:clamp(12px,1.2vw,14px)}

  /* Área do cubo – quadrada e canvas acima do halo */
  .cube-wrap{
    width:min(540px,85vw);
    aspect-ratio: 1 / 1;
    position:relative; margin:16px 0 18px;
    touch-action:none; overscroll-behavior:contain; user-select:none;
    display:grid; place-items:center;
  }
  .cube-wrap::before{
    content:""; position:absolute; inset:-12% -12% -6% -12%;
    border-radius:50%;
    background: radial-gradient(50% 50% at 50% 60%, rgba(42,87,255,.35), transparent 70%);
    filter: blur(42px); z-index:0;
  }
  #three-canvas{
    width:100%; height:100%; display:block;
    position:relative; z-index:1;
    touch-action:none; border-radius:18px;
  }

  /* form */
  .form{display:flex; gap:12px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap}
  .input{width:min(520px,78vw); height:46px; border-radius:999px; border:1px solid var(--ring); background:rgba(255,255,255,.04); color:var(--text); padding:0 18px; outline:none; font-size:15px; backdrop-filter:blur(4px)}
  .input::placeholder{color:#8a8aa2}
  .btn{height:46px; border-radius:999px; padding:0 20px; border:1px solid rgba(255,255,255,.22); font-weight:800; cursor:pointer; background:#fff; color:#0a0a0d; box-shadow:0 2px 0 rgba(255,255,255,.6) inset, 0 12px 30px rgba(255,255,255,.10); white-space:nowrap}
  .fineprint{color:#7b7b8a; font-size:12px; margin-top:8px}

  footer{padding:52px 20px; text-align:center; color:#7b7b8a; font-size:12px}

  @media (max-width:640px){
    .brand{font-size:clamp(26px,8vw,38px)}
    .title{font-size:clamp(16px,5vw,24px)}
    .subtitle{font-size:clamp(11px,3.2vw,13px)}
  }
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand" aria-label="Otenzza">
      <!-- Cubinho do logo -->
      <svg class="brand-cube" viewBox="0 0 48 48" aria-hidden="true">
        <defs>
          <linearGradient id="gTop" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#74b8ff"/><stop offset="1" stop-color="#4a86ff"/>
          </linearGradient>
          <linearGradient id="gLeft" x1="1" y1="0" x2="0" y2="1">
            <stop offset="0" stop-color="#3d5eff"/><stop offset="1" stop-color="#1733ff"/>
          </linearGradient>
          <linearGradient id="gRight" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#4a6aff"/><stop offset="1" stop-color="#244bff"/>
          </linearGradient>
        </defs>
        <polygon points="24,4 8,12 24,20 40,12" fill="url(#gTop)"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="url(#gLeft)"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="url(#gRight)"/>
        <polygon points="24,4 8,12 24,20 40,12" fill="none" stroke="rgba(255,255,255,.35)" stroke-width=".9"/>
        <polygon points="8,12 8,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
        <polygon points="40,12 40,28 24,36 24,20" fill="none" stroke="rgba(255,255,255,.25)" stroke-width=".9"/>
      </svg>
      <span>OTENZZA</span>
    </div>
  </header>

  <main class="hero">
    <div class="stack">
      <h1 class="title">Presence. Identity. Precision.</h1>
      <p class="subtitle">A private, intentional space. No feed. No vanity metrics. Just your Cube.</p>

      <!-- CUBO 3D -->
      <div class="cube-wrap" id="cube-wrap">
        <canvas id="three-canvas"></canvas>
      </div>

      <form class="form" onsubmit="event.preventDefault(); alert('Reserved. Welcome to the circle.');">
        <input class="input" type="email" placeholder="your@email.com" required aria-label="Email"/>
        <button class="btn" type="submit">Reserve early access</button>
      </form>
      <div class="fineprint">Founding members — limited circle.</div>
    </div>
  </main>

  <footer>© 2025 Otenzza.</footer>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    (function(){
      const container = document.getElementById('cube-wrap');
      const canvas    = document.getElementById('three-canvas');

      let renderer, scene, camera, outerCube, innerCube;
      let dragging=false, lx=0, ly=0, rx=-0.6, ry=0.8;
      let idle = true;

      /* ========= Procedural "fluid" texture (CanvasTexture animada) ========= */
      function makeFlowTexture(size=256){
        const c = document.createElement('canvas'); c.width = c.height = size;
        const ctx = c.getContext('2d');
        const img = ctx.createImageData(size,size); const data = img.data;

        const lerp=(a,b,t)=>a+(b-a)*t;
        const smooth=t=>t*t*(3-2*t);
        const hash=(x,y)=>{ const s=Math.sin(x*127.1+y*311.7)*43758.5453123; return s-Math.floor(s); };
        const noise=(x,y)=>{
          const xi=Math.floor(x), yi=Math.floor(y);
          const xf=x-xi, yf=y-yi;
          const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
          const u=smooth(xf), v=smooth(yf);
          return lerp(lerp(v00,v10,u), lerp(v01,v11,u), v);
        };
        const fbm=(x,y,oct=4)=>{
          let val=0, amp=0.5, freq=1.0;
          for(let i=0;i<oct;i++){ val += amp*noise(x*freq, y*freq); freq*=2.02; amp*=0.5; }
          return val;
        };

        let t=0;
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.MirroredRepeatWrapping;
        tex.anisotropy = 8;
        if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;

        function update(dt=0.016){
          t += dt;

          // parâmetros visuais
          const scale1 = 3.2, scale2 = 6.0;
          const speed1 = 0.15, speed2 = -0.10;
          const angle  = 0.55; const ca=Math.cos(angle), sa=Math.sin(angle);

          for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
              const nx = (x/size - 0.5), ny = (y/size - 0.5);

              // coordenadas rotacionadas (veias diagonais)
              const rx = nx*ca - ny*sa;
              const ry = nx*sa + ny*ca;

              // duas camadas de fbm com tempo distinto (efeito de fluxo)
              const n1 = fbm(rx*scale1 + t*speed1, ry*scale1 - t*speed1, 4);
              const n2 = fbm(rx*scale2 - t*speed2, ry*scale2 + t*speed2, 3);
              let v = 0.55*n1 + 0.45*n2;        // 0..1 (mistura)

              // brilho suave (highlights)
              const glow = Math.max(0, v-0.72) * 3.0; // realça picos
              v = Math.min(1, Math.max(0, v));

              // paleta clara: cyan/azul com toque sutil magenta nos highlights
              const c1 = [70, 180, 255];     // base
              const c2 = [190, 230, 255];    // highlight azul claro
              const r = Math.min(255, Math.round(lerp(c1[0], c2[0], v) + glow*40));
              const g = Math.min(255, Math.round(lerp(c1[1], c2[1], v) + glow*15));
              const b = Math.min(255, Math.round(lerp(c1[2], c2[2], v) + glow*35));

              const i=(y*size + x)*4;
              data[i  ] = r;
              data[i+1] = g;
              data[i+2] = b;
              data[i+3] = 255;
            }
          }
          ctx.putImageData(img,0,0);
          tex.needsUpdate = true;
        }

        return { texture: tex, update };
      }
      /* ========================================================================= */

      function init(){
        renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true, powerPreference:'high-performance'});
        if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene  = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
        camera.position.set(0, 0, 3.8);
        camera.lookAt(0,0,0);

        // Luzes
        scene.add(new THREE.AmbientLight(0xffffff, 0.55));
        const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,4,5); scene.add(dir);
        const rim = new THREE.PointLight(0x6d8bff, 0.7); rim.position.set(-4,-2,-3); scene.add(rim);

        // Geometrias
        const geo = new THREE.BoxGeometry(1,1,1);

        // Cubo externo: “vidro” leve e claro
        const outerMat = new THREE.MeshPhysicalMaterial({
          color: 0x6aa9ff,
          metalness: 0.06,
          roughness: 0.12,
          clearcoat: 0.6,
          clearcoatRoughness: 0.05,
          transparent: true,
          opacity: 0.55
        });
        outerCube = new THREE.Mesh(geo, outerMat);
        // Arestas suaves para definição
        const edges = new THREE.EdgesGeometry(geo);
        outerCube.add(new THREE.LineSegments(
          edges, new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.25})
        ));
        scene.add(outerCube);

        // Cubo interno: textura animada + blending aditivo (efeito “fluido”)
        const flow = makeFlowTexture(256);
        const innerMat = new THREE.MeshBasicMaterial({
          map: flow.texture,
          color: 0xffffff,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        innerCube = new THREE.Mesh(geo, innerMat);
        innerCube.scale.setScalar(0.82); // menor que o externo para “ficar dentro”
        outerCube.add(innerCube);        // como filho, fica sempre no interior

        // rotação inicial (mesma do setup antigo)
        applyRot();

        resize();

        // Interação (Pointer Events) + bloquear scroll
        canvas.addEventListener('pointerdown', onDown, {passive:false});
        canvas.addEventListener('pointermove', onMove, {passive:false});
        canvas.addEventListener('pointerup', onUp, {passive:false});
        canvas.addEventListener('pointercancel', onUp, {passive:false});
        canvas.addEventListener('wheel', e=>e.preventDefault(), {passive:false});

        // Loop de animação
        let last = performance.now();
        function tick(now){
          const dt = Math.min(0.05, (now-last)/1000); last = now;

          if(idle){ ry += 0.003; applyRot(); }
          // anima a textura (movimento dentro do cubo)
          flow.update(dt);
          // leve rotação do núcleo para reforçar o efeito
          innerCube.rotation.y += 0.12 * dt;
          innerCube.rotation.x -= 0.06 * dt;

          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      function applyRot(){ outerCube.rotation.x = rx; outerCube.rotation.y = ry; }

      function onDown(e){
        dragging = true; idle = false; lx = e.clientX; ly = e.clientY;
        canvas.setPointerCapture(e.pointerId);
        e.preventDefault();
      }
      function onMove(e){
        if(!dragging) return;
        const dx = e.clientX - lx;
        const dy = e.clientY - ly;
        ry += dx * 0.01;
        rx -= dy * 0.01;
        rx = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, rx));
        applyRot();
        lx = e.clientX; ly = e.clientY;
        e.preventDefault();
      }
      function onUp(e){
        dragging = false; idle = true;
        try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
      }

      function resize(){
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        // 60% menor que o padrão (como você pediu antes)
        const s = Math.min(w, h);
        outerCube.scale.setScalar(s / 600);
      }
      window.addEventListener('resize', resize);

      if (document.readyState === 'complete') init();
      else window.addEventListener('load', init);
    })();
  </script>
</body>
</html>
